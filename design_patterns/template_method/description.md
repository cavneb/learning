In this chapter we looked in detail at our first pattern, the Template Method pattern. The Template Method pattern is simply a fancy way of saying that if you want to vary an algorithm, one way to do so is to code the invariant part in a base class and to encapsulate the variable parts in methods that are defined by a number of subclasses. The base class can simply leave the methods completely undefined—in that case, the subclasses must supply the methods. Alternatively, the base class can provide a default implementation for the methods that the subclasses can override if they want.

Given that this was our first pattern, we also took a bit of a detour in which we explored one of the most important aspects of programming in Ruby: duck typing. Duck typing is a trade-off: You give up the compile-time safety of static typing, and in return you get back a lot of code clarity and programming flexibility.

Looking ahead, we will soon see that the Template Method pattern is such a basic object-oriented technique that it pops up in other patterns. In Chapter 13, for example, we will learn that the Factory Method pattern is simply the Template Method pattern applied to creating new objects. The problem that the Template Method pattern attacks is also reasonably pervasive. In fact, in the next chapter we will look at the Strategy pattern, which offers a different solution to the same problem—a solution that does not rely on inheritance in the same way that the Template Method pattern does.